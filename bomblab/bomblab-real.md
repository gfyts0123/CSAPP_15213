# Bomblab 实战

[TOC]

## 写在前面

这是随机生成的一个新炸弹，基本思路与练习一致，如果想要浏览更多拆炸弹细节和思路，请查阅[bomblab-practice](bomblab-practice.md)

## gdb 相关命令

```c
gdb -q bomb      //调试bomb程序
disas phase_1       //反汇编phase_1函数
x/s 0x804a264       //取出内存中0x804a264字符串的值
x/(8)g 0x402470       //取出0x402470开始，八个八字节单元（常用于switch表）
                     //如果是x/w读取字，x/b读取字节，x/h读取双字节，x/x按16进制显示变量
```

## 常用指令

```c
test S1, S2        //S1&S2比较，设置对应标志位
cmp S1, S2         //S2-S1比较
lea    //加载有效地址
jmp    //直接跳转
```

## 拆弹实验具体题目

### 第一题实战

```c
0x0000000000001204 <+0>:    sub    $0x8,%rsp
0x0000000000001208 <+4>:    lea    0x1781(%rip),%rsi        # 0x2990
0x000000000000120f <+11>:    callq  0x16c6 <strings_not_equal>   // 调用函数判断是否不相等，不相等返回1，相等返回0
0x0000000000001214 <+16>:    test   %eax,%eax
0x0000000000001216 <+18>:    jne    0x121d <phase_1+25>          // eax不为0则爆炸
0x0000000000001218 <+20>:    add    $0x8,%rsp
0x000000000000121c <+24>:    retq
0x000000000000121d <+25>:    callq  0x1956 <explode_bomb>
0x0000000000001222 <+30>:    jmp    0x1218 <phase_1+20>
```

在phase_1打上断点，stepi至+11，直接获取%rsi的值："I am not part of the problem. I am a Republican."

### 第二题实战

```c
   0x0000000000001224 <+0>:    push   %rbp
   0x0000000000001225 <+1>:    push   %rbx
   0x0000000000001226 <+2>:    sub    $0x28,%rsp
   0x000000000000122a <+6>:    mov    %fs:0x28,%rax
   0x0000000000001233 <+15>:    mov    %rax,0x18(%rsp)
   0x0000000000001238 <+20>:    xor    %eax,%eax                 // eax异或自身，eax=0
   0x000000000000123a <+22>:    mov    %rsp,%rsi
   0x000000000000123d <+25>:    callq  0x1992 <read_six_numbers>
   0x0000000000001242 <+30>:    cmpl   $0x0,(%rsp)
   0x0000000000001246 <+34>:    jne    0x124f <phase_2+43>       // rsp的值 !=0 跳转到+43爆炸
   0x0000000000001248 <+36>:    cmpl   $0x1,0x4(%rsp)
   0x000000000000124d <+41>:    je     0x1254 <phase_2+48>       // rsp+4的值==1 则跳转至+48避免爆炸
   0x000000000000124f <+43>:    callq  0x1956 <explode_bomb>
   0x0000000000001254 <+48>:    mov    %rsp,%rbx                 // rbx = rsp
   0x0000000000001257 <+51>:    lea    0x10(%rbx),%rbp           // rbp = rbx+16的值
   0x000000000000125b <+55>:    jmp    0x1266 <phase_2+66>       // 跳转至+66
   0x000000000000125d <+57>:    add    $0x4,%rbx                 // rbx +=4
   0x0000000000001261 <+61>:    cmp    %rbp,%rbx
   0x0000000000001264 <+64>:    je     0x1277 <phase_2+83>       // rbx==rbp则跳转至+83
   0x0000000000001266 <+66>:    mov    0x4(%rbx),%eax            // eax = rbx+4的值
   0x0000000000001269 <+69>:    add    (%rbx),%eax               // eax += rbx的值
   0x000000000000126b <+71>:    cmp    %eax,0x8(%rbx)
   0x000000000000126e <+74>:    je     0x125d <phase_2+57>       // rbx+8的值==eax则跳转至+57避免爆炸
   0x0000000000001270 <+76>:    callq  0x1956 <explode_bomb>
   0x0000000000001275 <+81>:    jmp    0x125d <phase_2+57>
   0x0000000000001277 <+83>:    mov    0x18(%rsp),%rax
   0x000000000000127c <+88>:    xor    %fs:0x28,%rax
   0x0000000000001285 <+97>:    jne    0x128e <phase_2+106>      // 金丝雀用法，发现原来%fs:0x28的值被覆盖后则栈溢出错误
   0x0000000000001287 <+99>:    add    $0x28,%rsp
   0x000000000000128b <+103>:    pop    %rbx
   0x000000000000128c <+104>:    pop    %rbp
   0x000000000000128d <+105>:    retq
   0x000000000000128e <+106>:    callq  0xe50 <__stack_chk_fail@plt>
```

answer: rsp开始依次存放数，要求第一个数为0，第二个数为1。

之后从下面这段代码知主体为斐波那契数列，输入0 1 1 2 3 5通关

```c
   0x0000000000001266 <+66>:    mov    0x4(%rbx),%eax            // eax = rbx+4的值
   0x0000000000001269 <+69>:    add    (%rbx),%eax               // eax += rbx的值
   0x000000000000126b <+71>:    cmp    %eax,0x8(%rbx)
   0x000000000000126e <+74>:    je     0x125d <phase_2+57>       // rbx+8的值==eax则跳转至+57避免爆炸
```

其他细节：rbp为尾指针，rbx和rax中间变量完成比较操作

### 第三题实战

```c
   0x0000555555555293 <+0>:    sub    $0x18,%rsp
   0x0000555555555297 <+4>:    mov    %fs:0x28,%rax
   0x00005555555552a0 <+13>:    mov    %rax,0x8(%rsp)
   0x00005555555552a5 <+18>:    xor    %eax,%eax              // eax = 0
   0x00005555555552a7 <+20>:    lea    0x4(%rsp),%rcx         // rcx = rsp+4的值
   0x00005555555552ac <+25>:    mov    %rsp,%rdx              // rdx = rsp
   0x00005555555552af <+28>:    lea    0x1987(%rip),%rsi      // 访问此处%rsi得到"%d %d"得到输入为两个整数
   0x00005555555552b6 <+35>:    callq  0x555555554ef0 <__isoc99_sscanf@plt>
   0x00005555555552bb <+40>:    cmp    $0x1,%eax
   0x00005555555552be <+43>:    jle    0x5555555552dd <phase_3+74>     // eax<=1 跳转至+74爆炸（检测输入是否两个整数）
   0x00005555555552c0 <+45>:    cmpl   $0x7,(%rsp)
   0x00005555555552c4 <+49>:    ja     0x555555555363 <phase_3+208>    // rsp的值>7跳转至+208爆炸（输入小于7）
   0x00005555555552ca <+55>:    mov    (%rsp),%eax                     // eax = rsp的值
   0x00005555555552cd <+58>:    lea    0x172c(%rip),%rdx               // rdx = rip+0x172c的值
   0x00005555555552d4 <+65>:    movslq (%rdx,%rax,4),%rax              // rax = rdx+4*rax
   0x00005555555552d8 <+69>:    add    %rdx,%rax                       // rax += rdx = 2*rdx + 4*rax
   0x00005555555552db <+72>:    jmpq   *%rax                           // 间接跳转，跳转至rax的地址值
   0x00005555555552dd <+74>:    callq  0x555555555956 <explode_bomb>
   0x00005555555552e2 <+79>:    jmp    0x5555555552c0 <phase_3+45>     // 跳转至+45
   0x00005555555552e4 <+81>:    mov    $0x18c,%eax                     // eax = 0x18c
   0x00005555555552e9 <+86>:    jmp    0x5555555552f0 <phase_3+93>     // 跳转至+93
   0x00005555555552eb <+88>:    mov    $0x0,%eax
   0x00005555555552f0 <+93>:    sub    $0x95,%eax
   0x00005555555552f5 <+98>:    add    $0x3a8,%eax
   0x00005555555552fa <+103>:    sub    $0x390,%eax
   0x00005555555552ff <+108>:    add    $0x390,%eax
   0x0000555555555304 <+113>:    sub    $0x390,%eax
   0x0000555555555309 <+118>:    add    $0x390,%eax
   0x000055555555530e <+123>:    sub    $0x390,%eax
   0x0000555555555313 <+128>:    cmpl   $0x5,(%rsp)
   0x0000555555555317 <+132>:    jg     0x55555555531f <phase_3+140>    // rsp的值>5则爆炸（输入小于等于5）
   0x0000555555555319 <+134>:    cmp    %eax,0x4(%rsp)
   0x000055555555531d <+138>:    je     0x555555555324 <phase_3+145>    // rsp+4的值==eax则跳转至+145避免爆炸
   0x000055555555531f <+140>:    callq  0x555555555956 <explode_bomb>
   0x0000555555555324 <+145>:    mov    0x8(%rsp),%rax
   0x0000555555555329 <+150>:    xor    %fs:0x28,%rax
   0x0000555555555332 <+159>:    jne    0x55555555536f <phase_3+220>    // 异或不为0跳转至栈溢出报错
   0x0000555555555334 <+161>:    add    $0x18,%rsp                      // 加回栈值返回
   0x0000555555555338 <+165>:    retq
   ————————————————————————————————————————————————————————————————————一个switch表
   0x0000555555555339 <+166>:    mov    $0x0,%eax
   0x000055555555533e <+171>:    jmp    0x5555555552f5 <phase_3+98>
   0x0000555555555340 <+173>:    mov    $0x0,%eax
   0x0000555555555345 <+178>:    jmp    0x5555555552fa <phase_3+103>
   0x0000555555555347 <+180>:    mov    $0x0,%eax
   0x000055555555534c <+185>:    jmp    0x5555555552ff <phase_3+108>
   0x000055555555534e <+187>:    mov    $0x0,%eax
   0x0000555555555353 <+192>:    jmp    0x555555555304 <phase_3+113>
   0x0000555555555355 <+194>:    mov    $0x0,%eax
   0x000055555555535a <+199>:    jmp    0x555555555309 <phase_3+118>
   0x000055555555535c <+201>:    mov    $0x0,%eax
   0x0000555555555361 <+206>:    jmp    0x55555555530e <phase_3+123>
   0x0000555555555363 <+208>:    callq  0x555555555956 <explode_bomb>
   0x0000555555555368 <+213>:    mov    $0x0,%eax
   0x000055555555536d <+218>:    jmp    0x555555555313 <phase_3+128>
   0x000055555555536f <+220>:    callq  0x555555554e50 <__stack_chk_fail@plt>
```

answer：我们知道第一个输入（rsp）小于等于5，且是unsigned所以值>=0。第二个输入需要等于处理后的eax值，同第三题处理方案。
这里我们偷懒直接试探出0 271

### 第四题实战

代码：

```c
   0x00005555555553b3 <+0>:    sub    $0x18,%rsp
   0x00005555555553b7 <+4>:    mov    %fs:0x28,%rax
   0x00005555555553c0 <+13>:    mov    %rax,0x8(%rsp)
   0x00005555555553c5 <+18>:    xor    %eax,%eax
   0x00005555555553c7 <+20>:    lea    0x4(%rsp),%rcx
   0x00005555555553cc <+25>:    mov    %rsp,%rdx
   0x00005555555553cf <+28>:    lea    0x1867(%rip),%rsi        // 同样为"%d %d"输入两个整数
   0x00005555555553d6 <+35>:    callq  0x555555554ef0 <__isoc99_sscanf@plt>
   0x00005555555553db <+40>:    cmp    $0x2,%eax
   0x00005555555553de <+43>:    jne    0x5555555553e6 <phase_4+51>     // eax!=2 爆炸
   0x00005555555553e0 <+45>:    cmpl   $0xe,(%rsp)
   0x00005555555553e4 <+49>:    jbe    0x5555555553eb <phase_4+56>     // rsp的值<=14跳转至+56，否则爆炸
   0x00005555555553e6 <+51>:    callq  0x555555555956 <explode_bomb>
   0x00005555555553eb <+56>:    mov    $0xe,%edx                       // edx = 14
   0x00005555555553f0 <+61>:    mov    $0x0,%esi                       // esi = 0
   0x00005555555553f5 <+66>:    mov    (%rsp),%edi                     // edi = rsp的值
   0x00005555555553f8 <+69>:    callq  0x555555555374 <func4>
   0x00005555555553fd <+74>:    cmp    $0x6,%eax
   0x0000555555555400 <+77>:    jne    0x555555555409 <phase_4+86>     // 最终eax!=6跳转至+86爆炸
   0x0000555555555402 <+79>:    cmpl   $0x6,0x4(%rsp)
   0x0000555555555407 <+84>:    je     0x55555555540e <phase_4+91>     // rsp+4的值==6 跳转至+91避免爆炸
   0x0000555555555409 <+86>:    callq  0x555555555956 <explode_bomb>
   0x000055555555540e <+91>:    mov    0x8(%rsp),%rax
   0x0000555555555413 <+96>:    xor    %fs:0x28,%rax                   // 日常金丝雀保护栈
   0x000055555555541c <+105>:    jne    0x555555555423 <phase_4+112>
   0x000055555555541e <+107>:    add    $0x18,%rsp
   0x0000555555555422 <+111>:    retq
   0x0000555555555423 <+112>:    callq  0x555555554e50 <__stack_chk_fail@plt>
```

由上述代码可以知道：

- 第一个输入<=14，第二个输入=6.
- func4的参数：edx = 14， esi = 0， edi = 第一个输入记为x, ecx = 第二个输入 = 6
- func4返回需要为6

func4：

```c
   0x0000555555555374 <+0>:    sub    $0x8,%rsp
   0x0000555555555378 <+4>:    mov    %edx,%eax
   0x000055555555537a <+6>:    sub    %esi,%eax
   0x000055555555537c <+8>:    mov    %eax,%ecx
   0x000055555555537e <+10>:    shr    $0x1f,%ecx
   0x0000555555555381 <+13>:    add    %eax,%ecx
   0x0000555555555383 <+15>:    sar    %ecx
   0x0000555555555385 <+17>:    add    %esi,%ecx
   0x0000555555555387 <+19>:    cmp    %edi,%ecx
   0x0000555555555389 <+21>:    jg     0x555555555399 <func4+37>    // ecx>edi跳转至+37
   0x000055555555538b <+23>:    mov    $0x0,%eax
   0x0000555555555390 <+28>:    cmp    %edi,%ecx
   0x0000555555555392 <+30>:    jl     0x5555555553a5 <func4+49>    // ecx<edi跳转至+49
   0x0000555555555394 <+32>:    add    $0x8,%rsp
   0x0000555555555398 <+36>:    retq
   0x0000555555555399 <+37>:    lea    -0x1(%rcx),%edx
   0x000055555555539c <+40>:    callq  0x555555555374 <func4>
   0x00005555555553a1 <+45>:    add    %eax,%eax
   0x00005555555553a3 <+47>:    jmp    0x555555555394 <func4+32>
   0x00005555555553a5 <+49>:    lea    0x1(%rcx),%esi
   0x00005555555553a8 <+52>:    callq  0x555555555374 <func4>
   0x00005555555553ad <+57>:    lea    0x1(%rax,%rax,1),%eax
   0x00005555555553b1 <+61>:    jmp    0x555555555394 <func4+32>
```

同样翻译为python

```python
def func4(esi = 0, edx = 14,ecx = 6):
   result = edx - esi
   ecx = result>>31              # 逻辑右移
   ecx = (ecx + result) >>1 +esi     # 算术右移
   if ecx > edi:
      result = func4(esi = esi, edx = ecx-1,ecx = ecx)
      return result*2
   else:
      result = 0
      if ecx< edi:            # 一旦一开始进入这个分支，那么最终结果一定不是6，所以x必须<=ecx = 7
         result = func4(esi = ecx+1, edx = edx,ecx = ecx)
         return result*2 + 1
      else:
         return result
```

这里穷举，得到x=6时通过。所以最终结果取6 6

### 第五题实战

代码

```c
   0x0000000000001428 <+0>:    push   %rbx
   0x0000000000001429 <+1>:    mov    %rdi,%rbx              // rbx = rdi
   0x000000000000142c <+4>:    callq  0x16a9 <string_length>
   0x0000000000001431 <+9>:    cmp    $0x6,%eax
   0x0000000000001434 <+12>:    jne    0x1467 <phase_5+63>    // 不相等跳转至+63爆炸，说明输入字串长度为6
   0x0000000000001436 <+14>:    mov    %rbx,%rax
   0x0000000000001439 <+17>:    lea    0x6(%rbx),%rdi         // rdi = rbx+6的值
   0x000000000000143d <+21>:    mov    $0x0,%ecx              // ecx = 0
   0x0000000000001442 <+26>:    lea    0x15d7(%rip),%rsi      // 0x2a20 <array.3417>
   0x0000000000001449 <+33>:    movzbl (%rax),%edx            // edx = rax的值，通过gdb调试知晓此即为我们输入的字符串akshdj
   0x000000000000144c <+36>:    and    $0xf,%edx              // edx = edx最后四位
   0x000000000000144f <+39>:    add    (%rsi,%rdx,4),%ecx     // ecx = ecx + rsi+ 4*edx(地址*4)
   0x0000000000001452 <+42>:    add    $0x1,%rax              // rax+=1
   0x0000000000001456 <+46>:    cmp    %rdi,%rax
   0x0000000000001459 <+49>:    jne    0x1449 <phase_5+33>    // rax!=rdi跳转至+33，gdb调试知晓rdi是尾指针，此处要循环6次
   0x000000000000145b <+51>:    cmp    $0x25,%ecx
   0x000000000000145e <+54>:    je     0x1465 <phase_5+61>    // ecx==37跳转至+61避免爆炸
   0x0000000000001460 <+56>:    callq  0x1956 <explode_bomb>
   0x0000000000001465 <+61>:    pop    %rbx
   0x0000000000001466 <+62>:    retq
   0x0000000000001467 <+63>:    callq  0x1956 <explode_bomb>
   0x000000000000146c <+68>:    jmp    0x1436 <phase_5+14>
```

answer:首先获取rsi处数组信息

```c
0x555555556a20 <array.3417>:    0x0000000a 00000002    0x00000001 00000006
0x555555556a30 <array.3417+16>:    0x00000010  0000000c    0x00000003  00000009
0x555555556a40 <array.3417+32>:    0x00000007  00000004    0x00000005  0000000e
0x555555556a50 <array.3417+48>:    0x00000008  0000000b    0x0000000d  0000000f
```

对应array：[2,a,6,1,c,16,9,3,4,7,e,5,b,8,f,d]。
注：1个int型32位，64位机中中2个int放一行，其中小端编址所以后面的int实际为前面的值。
计算ecx的值时，取我们输入字符的最后四位（asc2码）索引数组的值，如a(0001)取到10，b(0010)取到6

知道此我们便可很容易地得到一组答案：5*6+7(bbbbbi)

### 第六题实战

代码

```c
   0x000055555555546e <+0>:    push   %r13
   0x0000555555555470 <+2>:    push   %r12
   0x0000555555555472 <+4>:    push   %rbp
   0x0000555555555473 <+5>:    push   %rbx
   0x0000555555555474 <+6>:    sub    $0x68,%rsp
   0x0000555555555478 <+10>:    mov    %fs:0x28,%rax
   0x0000555555555481 <+19>:    mov    %rax,0x58(%rsp)     // rsp+0x58存储金丝雀值
   0x0000555555555486 <+24>:    xor    %eax,%eax           // eax = 0
   0x0000555555555488 <+26>:    mov    %rsp,%r12           // r12 = rsp
   0x000055555555548b <+29>:    mov    %r12,%rsi           // rsi = rsp
   0x000055555555548e <+32>:    callq  0x555555555992 <read_six_numbers>
   0x0000555555555493 <+37>:    mov    $0x0,%r13d          // r13d = 0
   0x0000555555555499 <+43>:    jmp    0x5555555554c0 <phase_6+82>     //跳转至+82
   0x000055555555549b <+45>:    callq  0x555555555956 <explode_bomb>
   0x00005555555554a0 <+50>:    jmp    0x5555555554cf <phase_6+97>
   0x00005555555554a2 <+52>:    add    $0x1,%ebx
   0x00005555555554a5 <+55>:    cmp    $0x5,%ebx
   0x00005555555554a8 <+58>:    jg     0x5555555554bc <phase_6+78>
   0x00005555555554aa <+60>:    movslq %ebx,%rax           // rax = ebx
   0x00005555555554ad <+63>:    mov    (%rsp,%rax,4),%eax  // eax = rsp + 4*rax即我们依次输入的数
   0x00005555555554b0 <+66>:    cmp    %eax,0x0(%rbp)
   0x00005555555554b3 <+69>:    jne    0x5555555554a2 <phase_6+52>     // eax != rbp的值跳转至+52
                                                                     // rbp是当前数指针
                                                                     // 所以每个数都不相同
   0x00005555555554b5 <+71>:    callq  0x555555555956 <explode_bomb>
   0x00005555555554ba <+76>:    jmp    0x5555555554a2 <phase_6+52>
   0x00005555555554bc <+78>:    add    $0x4,%r12
   0x00005555555554c0 <+82>:    mov    %r12,%rbp           // rbp = r12
   0x00005555555554c3 <+85>:    mov    (%r12),%eax         // eax = r12的值
   0x00005555555554c7 <+89>:    sub    $0x1,%eax           // eax -= 1
   0x00005555555554ca <+92>:    cmp    $0x5,%eax
   0x00005555555554cd <+95>:    ja     0x55555555549b <phase_6+45>  // eax>5跳转至+45爆炸
                                                                  // 说明每个输入数都<=6
   0x00005555555554cf <+97>:    add    $0x1,%r13d                   // r13d += 1
   0x00005555555554d3 <+101>:    cmp    $0x6,%r13d
   0x00005555555554d7 <+105>:    je     0x55555555550e <phase_6+160> // r13d==6跳转至+160跳出循环
   0x00005555555554d9 <+107>:    mov    %r13d,%ebx                   // ebx = r13d
   0x00005555555554dc <+110>:    jmp    0x5555555554aa <phase_6+60>  // 跳转至+60
   ——————————————————————————————————————————————————————————————————————————————————————
   0x00005555555554de <+112>:    mov    0x8(%rdx),%rdx               // rdx = rdx+8的值
   0x00005555555554e2 <+116>:    add    $0x1,%eax                    // eax +=1
   0x00005555555554e5 <+119>:    cmp    %ecx,%eax
   0x00005555555554e7 <+121>:    jne    0x5555555554de <phase_6+112> // eax!= ecx跳转至+112
   0x00005555555554e9 <+123>:    mov    %rdx,0x20(%rsp,%rsi,8)       // rsp + rsi*8 + 0x20写入rdx
   0x00005555555554ee <+128>:    add    $0x1,%rsi                    // rsi+=1
   0x00005555555554f2 <+132>:    cmp    $0x6,%rsi
   0x00005555555554f6 <+136>:    je     0x555555555515 <phase_6+167> // rsi==6跳转至+167退出循环
   0x00005555555554f8 <+138>:    mov    (%rsp,%rsi,4),%ecx        // ecx = rsp+4*rsi
   0x00005555555554fb <+141>:    mov    $0x1,%eax                 // eax = 1
   0x0000555555555500 <+146>:    lea    0x202d29(%rip),%rdx       // 0x555555758230 <node1>
   0x0000555555555507 <+153>:    cmp    $0x1,%ecx
   0x000055555555550a <+156>:    jg     0x5555555554de <phase_6+112> // ecx>1跳转至+112
   0x000055555555550c <+158>:    jmp    0x5555555554e9 <phase_6+123> // 否则跳转至+123
   0x000055555555550e <+160>:    mov    $0x0,%esi                 // esi = 0
   0x0000555555555513 <+165>:    jmp    0x5555555554f8 <phase_6+138>    // 跳转至+138
——————————————————————————————————————————————————————————————————————————————————————
   0x0000555555555515 <+167>:    mov    0x20(%rsp),%rbx        // rbx = rsp+0x20的值
   0x000055555555551a <+172>:    mov    0x28(%rsp),%rax        // rax = rsp+0x28的值
   0x000055555555551f <+177>:    mov    %rax,0x8(%rbx)         // rbx+8的值 = rax
   0x0000555555555523 <+181>:    mov    0x30(%rsp),%rdx        // rdx = rsp+0x30的值
   0x0000555555555528 <+186>:    mov    %rdx,0x8(%rax)         // rax+8的值 = rdx
   0x000055555555552c <+190>:    mov    0x38(%rsp),%rax        // rax = rsp+0x38的值
   0x0000555555555531 <+195>:    mov    %rax,0x8(%rdx)         // rdx+8的值 = rax
   0x0000555555555535 <+199>:    mov    0x40(%rsp),%rdx        // rdx = rsp+0x40的值
   0x000055555555553a <+204>:    mov    %rdx,0x8(%rax)         // rax+8的值 = rdx
   0x000055555555553e <+208>:    mov    0x48(%rsp),%rax        // rax = rsp+0x48的值
   0x0000555555555543 <+213>:    mov    %rax,0x8(%rdx)         // rdx+8的值 = rax
   0x0000555555555547 <+217>:    movq   $0x0,0x8(%rax)         // rax+8的值 = 0
   0x000055555555554f <+225>:    mov    $0x5,%ebp              // ebp = 5
   0x0000555555555554 <+230>:    jmp    0x55555555555f <phase_6+241>    // 跳转至+241
   0x0000555555555556 <+232>:    mov    0x8(%rbx),%rbx                  // rbx = rbx+8的值
   0x000055555555555a <+236>:    sub    $0x1,%ebp                       // ebp -= 1
   0x000055555555555d <+239>:    je     0x555555555570 <phase_6+258>    // ebp == 0 则退出
   0x000055555555555f <+241>:    mov    0x8(%rbx),%rax                  // rax = rbx+8的值
   0x0000555555555563 <+245>:    mov    (%rax),%eax                     // eax = rax的值
   0x0000555555555565 <+247>:    cmp    %eax,(%rbx)
   0x0000555555555567 <+249>:    jge    0x555555555556 <phase_6+232>    // rbx的值>eax跳转至+232
   0x0000555555555569 <+251>:    callq  0x555555555956 <explode_bomb>   // 否则爆炸
   0x000055555555556e <+256>:    jmp    0x555555555556 <phase_6+232>
   0x0000555555555570 <+258>:    mov    0x58(%rsp),%rax
   0x0000555555555575 <+263>:    xor    %fs:0x28,%rax
   0x000055555555557e <+272>:    jne    0x55555555558b <phase_6+285>
   0x0000555555555580 <+274>:    add    $0x68,%rsp
   0x0000555555555584 <+278>:    pop    %rbx
   0x0000555555555585 <+279>:    pop    %rbp
   0x0000555555555586 <+280>:    pop    %r12
   0x0000555555555588 <+282>:    pop    %r13
   0x000055555555558a <+284>:    retq
   0x000055555555558b <+285>:    callq  0x555555554e50 <__stack_chk_fail@plt>
```

- key1：输入6个0~6的数，每个数不相同

- key2：

`mov %rdx,0x20(%rsp,%rsi,8)` 即rdx的值有选择地依次赋到rsp+20开始的6个数（如题目六所示）
假设输入1 2 ……即：rsp+0x20写入0x58230的值（0x0000034c），rsp+0x28写入0x58240的值（0x000001f5）
6个数分别为0x034c(第2大), 0x01f5(第5大), 0x03c8(第1大), 0x0343(第3大), 0x022f(第4大), 不存在（注意后面会赋值为0）
rdx的值如下：

```c
0x555555758230 <node1>:    0x4c    0x03    0x00    0x00    0x01    0x00    0x00    0x00
0x555555758238 <node1+8>:    0x40    0x82    0x75    0x55    0x55    0x55    0x00    0x00
0x555555758240 <node2>:    0xf5    0x01    0x00    0x00    0x02    0x00    0x00    0x00
0x555555758248 <node2+8>:    0x50    0x82    0x75    0x55    0x55    0x55    0x00    0x00
0x555555758250 <node3>:    0xc8    0x03    0x00    0x00    0x03    0x00    0x00    0x00
0x555555758258 <node3+8>:    0x60    0x82    0x75    0x55    0x55    0x55    0x00    0x00
0x555555758260 <node4>:    0x43    0x03    0x00    0x00    0x04    0x00    0x00    0x00
0x555555758268 <node4+8>:    0x70    0x82    0x75    0x55    0x55    0x55    0x00    0x00
0x555555758270 <node5>:    0x2f    0x02    0x00    0x00    0x05    0x00    0x00    0x00
0x555555758278 <node5+8>:    0x10    0x81    0x75    0x55    0x55    0x55    0x00    0x00
```

- key3：只有5个node，最后一个赋0

- key4：最后一层循环，要求每一个前面的值比后面的值大，否则爆炸。

综上得到答案：`3 1 4 5 2 6`

### secret phase

由于时间原因没有推进该项

### 实战结果集合

```c
I am not part of the problem. I am a Republican.
0 1 1 2 3 5
0 271
6 6
bbbbbi
3 1 4 5 2 6
```
